//
// Created by Иван Черемисенов on 08.02.2023.
//

#include <iostream>
#include <cmath>


/**
 *  Структура комплексного числа
 */
struct st_complex {
	/**
	 * В C++ существуют ключевые слова для защиты полей объектов.
	 * После ключевого слова private идут переменные, доступ к которым закрыт за пределами структуры.
	 */
 private:
	double re;
	double im;

	/**
	 * Для обозначения полей с открытым доступом используется ключевое слово public.
	 */
 public:
	/**
	 * Для удобства инициализации структуры в C++ существует специальны метод, который вызывается при создании объекта.
	 * У этого метода нет возвращаемого значения, так как он возвращает объект структуры.
	 * В аргументах можно указать переменные необходимые для инициализации.
	 *
	 * @param re_in действительная часть для инициализации числа
	 * @param im_in мнимая часть для инициализации числа
	 *
	 * @example st_complex z(1, 2); // пример инициализации
	 */
	st_complex(double re_in, double im_in) {
		re = re_in;
		im = im_in;
	}

	/**
	 * Конструкторы, как и обычные методы, можно перегружать. Напишем конструктор для преобразования действительного
	 * числа в комплексное.
	 *
	 * @param real действительное число
	 *
	 * Конструктор с одним параметром называется конструктором преобразования.
	 *
	 * @example st_complex z(5); // Пример инициализации преобразования
	 */
	st_complex(double real) {
		re = real;
		im = 0;
	}

	/**
	 * Так же можно указать конструктор, который будет вызываться в случае, когда параметры не передаются.
	 *
	 * @example st_complex z; или st_complex z();
	 *
	 * Такой конструктор называется конструктором по умолчанию.
	 */
	st_complex() {
		re = 0;
		im = 0;
	}

	/**
	 * Метод печати
	 */
	void print() {
		std::cout << re << "+" << im << "i" << std::endl;
	}

	/**
	 * Метод получения модуля комплексного числа
	 * @return модуль числа
	 *
	 * В методы структуры всегда неявно передается указатель *this,
	 * с помощью которого методы получают доступ к полям структуры.
	 *
	 * @example double modulo() { return sqrt (this->im * this->im + this->re + this->re); }
	 */
	double modulo() {
		return sqrt(re * re + im * im);
	}

	/**
	 * Так как мы закрыли поля re и im структуры, необходимо предоставить метод для их изменения.
	 *
	 * @param re_in новая действительная часть числа
	 * @param im_in новая мнимая часть числа
	 */
	void set(double re_in, double im_in) {
		re = re_in;
		im = im_in;
	}

	/**
	 * Для управления удалением объекта можно явно указать функцию, вызываемую при удалении объекта.
	 * Такую функцию называют деструктором
	 */
	 ~st_complex() {
		 std::cout << "Вызван деструктор" << std::endl;
	 }
};

/**
 * Пример 1
 */
int example1 () 
	st_complex z1;
	z1.set(4, 5);

	z1.print();

	std::cout << "mod: " << z1.modulo() << std::endl;

	return 0;
}

int main() {
	std::cout << "Lesson 2" << std::endl;

	example1();

	return 0;
}